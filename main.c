#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <time.h>
#include "monocypher.h"
#include "monocypher-ed25519.h"

void xed25519_sign(uint8_t signature[64],
                   const uint8_t secret_key[32],
                   const uint8_t random[64],
                   const uint8_t *message, size_t message_size)
{
	static const uint8_t zero   [32] = {0};
	static const uint8_t minus_1[32] = {
		0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
		0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	};
	static const uint8_t prefix[32] = {
		0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	};

	/* Key pair (a, A) */
	uint8_t A[32];  /* XEdDSA public key  */
	uint8_t a[32];  /* XEdDSA private key */
	crypto_eddsa_trim_scalar(a, secret_key);
	crypto_eddsa_scalarbase(A, a);
	int is_negative = A[31] & 0x80; /* Retrieve sign bit */
	A[31] &= 0x7f;                  /* Clear sign bit    */
	if (is_negative) {
		/* a = -a */
		crypto_eddsa_mul_add(a, a, minus_1, zero);
	}

	/* Secret nonce r */
	uint8_t r[64];
	crypto_sha512_ctx ctx;
	crypto_sha512_init  (&ctx);
	crypto_sha512_update(&ctx, prefix , 32);
	crypto_sha512_update(&ctx, a      , 32);
	crypto_sha512_update(&ctx, message, message_size);
	crypto_sha512_update(&ctx, random , 64);
	crypto_sha512_final (&ctx, r);
	crypto_eddsa_reduce(r, r);

	/* First half of the signature R */
	uint8_t R[32];
	crypto_eddsa_scalarbase(R, r);

	/* hash(R || A || M) */
	uint8_t H[64];
	crypto_sha512_init  (&ctx);
	crypto_sha512_update(&ctx, R      , 32);
	crypto_sha512_update(&ctx, A      , 32);
	crypto_sha512_update(&ctx, message, message_size);
	crypto_sha512_final (&ctx, H);
	crypto_eddsa_reduce(H, H);

	/* Signature */
	memcpy(signature, R, 32);
	crypto_eddsa_mul_add(signature + 32, a, H, r);

	/* Wipe secrets (A, R, and H are not secret) */
	crypto_wipe(a, 32);
	crypto_wipe(r, 32);
}

int xed25519_verify(const uint8_t signature[64],
                    const uint8_t public_key[32],
                    const uint8_t *message, size_t message_size)
{
	/* Convert X25519 key to EdDSA */
	uint8_t A[32];
	crypto_x25519_to_eddsa(A, public_key);

	/* hash(R || A || M) */
	uint8_t H[64];
	crypto_sha512_ctx ctx;
	crypto_sha512_init  (&ctx);
	crypto_sha512_update(&ctx, signature, 32);
	crypto_sha512_update(&ctx, A        , 32);
	crypto_sha512_update(&ctx, message  , message_size);
	crypto_sha512_final (&ctx, H);
	crypto_eddsa_reduce(H, H);

	/* Check signature */
	return crypto_eddsa_check_equation(signature, A, H);
}

void test1(void) {
	uint8_t signature[64] = {0};
    uint8_t random[64];
    uint8_t secret_key[32];
    uint8_t public_key[32] = {0};
    memset(secret_key, 1, sizeof(secret_key));
    memset(random, 2, sizeof(random));
    crypto_x25519_public_key(public_key, secret_key);
    uint8_t message[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
	0x17,0xa2,0x44,0x69,0xb8,0x61,0x37,0xe8,0xc2,0x69,0xc1,0x95,0xe0,0x56,0xad,0x17,0x05,0xdb,0xd1,0xfc,0x7a,0x77,0x60,0xe9,0xfb,0xd8,0x15,0x8b,0xf2,0xc2,0x6a,0x23,
	0x87,0xf0,0x83,0x67,0xbd,0xd1,0xd4,0x93,0x12,0x80,0xc3,0x91,0x45,0x9d,0xb7,0x91,0x01,0xb6,0xdf,0xb7,0x25,0xdb,0x97,0x86,0xb9,0x10,0xf6,0xe7,0xbc,0x6f,0x4c,0x1e,
	0x65,0x14,0x49,0x54,0x65,0x14,0x57,0x64};
    xed25519_sign(signature, secret_key,random,message, sizeof(message));
    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    // printf("\nsecret_key:\n");
    // for (int i=0; i<sizeof(secret_key); i++)
        // printf("0x%.02x,",secret_key[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);

    int result = xed25519_verify(signature, public_key, message, sizeof(message));
	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);
}

void test2(void) {
	// signature from Server
	uint8_t signature[64] = {0x96,0x8f,0xfd,0x3e,0x52,0x25,0xe3,0xf1,0xff,0xc3,0x84,0x08,0x87,0xaa,0x9c,0x54,0x2d,0x3c,0xc6,0x33,0xc2,0x18,0x1c,0xc9,0xc5,0xe1,0x86,0x5d,0x0c,0xe4,0x69,0x0c,
							 0x2b,0x6a,0x42,0x20,0xda,0x61,0xc5,0xe5,0x0f,0x8e,0x64,0x2e,0x36,0xb3,0x80,0x06,0x28,0x0a,0x2d,0xe3,0x8f,0x1e,0xfc,0x2c,0x0c,0xa6,0x80,0xa3,0x54,0xde,0x69,0x03};
    uint8_t random[64];
    uint8_t secret_key[32];
    uint8_t public_key[32] = {0x27,0x92,0xc2,0x13,0xa9,0xf1,0x6d,0x08,0x0c,0x55,0xf1,0xd4,0xee,0x68,0x01,0x74,0x06,0x30,0x2a,0x6e,0xe6,0xe1,0x9e,0xae,0x01,0x2f,0xdb,0xb4,0xc4,0x7a,0x20,0x03};
    memset(secret_key, 1, sizeof(secret_key));
    memset(random, 2, sizeof(random));
    // crypto_x25519_public_key(public_key, secret_key);
	// message from server
    uint8_t message[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
	0x17,0xa2,0x44,0x69,0xb8,0x61,0x37,0xe8,0xc2,0x69,0xc1,0x95,0xe0,0x56,0xad,0x17,0x05,0xdb,0xd1,0xfc,0x7a,0x77,0x60,0xe9,0xfb,0xd8,0x15,0x8b,0xf2,0xc2,0x6a,0x23,
	0x87,0xf0,0x83,0x67,0xbd,0xd1,0xd4,0x93,0x12,0x80,0xc3,0x91,0x45,0x9d,0xb7,0x91,0x01,0xb6,0xdf,0xb7,0x25,0xdb,0x97,0x86,0xb9,0x10,0xf6,0xe7,0xbc,0x6f,0x4c,0x1e,
	0x65,0x14,0x49,0x54,0x65,0x14,0x57,0x64};
    // xed25519_sign(signature, secret_key,random,message, sizeof(message));
    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    // printf("\nsecret_key:\n");
    // for (int i=0; i<sizeof(secret_key); i++)
    //     printf("0x%.02x,",secret_key[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);

    int result = xed25519_verify(signature, public_key, message, sizeof(message));
	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);
}

int main(void) {

	printf("test 1\n");
    test1();
	printf("test 2\n");
	test2();
    return 0;
}

