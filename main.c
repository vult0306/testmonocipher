#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <time.h>
#include "monocypher.h"
#include "monocypher-ed25519.h"
#define X25519_KEY_LEN      (32)

void xed25519_sign(uint8_t signature[64],
                   const uint8_t secret_key[X25519_KEY_LEN],
                   const uint8_t random[64],
                   const uint8_t *message, size_t message_size)
{
	static const uint8_t zero   [X25519_KEY_LEN] = {0};
	static const uint8_t minus_1[X25519_KEY_LEN] = {
		0xec, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
		0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	};
	static const uint8_t prefix[X25519_KEY_LEN] = {
		0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	};

	/* Key pair (a, A) */
	uint8_t A[X25519_KEY_LEN];  /* XEdDSA public key  */
	uint8_t a[X25519_KEY_LEN];  /* XEdDSA private key */
	crypto_eddsa_trim_scalar(a, secret_key);
	crypto_eddsa_scalarbase(A, a);
	int is_negative = A[31] & 0x80; /* Retrieve sign bit */
	A[31] &= 0x7f;                  /* Clear sign bit    */
	if (is_negative) {
		/* a = -a */
		crypto_eddsa_mul_add(a, a, minus_1, zero);
	}

	/* Secret nonce r */
	uint8_t r[64];
	crypto_sha512_ctx ctx;
	crypto_sha512_init  (&ctx);
	crypto_sha512_update(&ctx, prefix , X25519_KEY_LEN);
	crypto_sha512_update(&ctx, a      , X25519_KEY_LEN);
	crypto_sha512_update(&ctx, message, message_size);
	crypto_sha512_update(&ctx, random , 64);
	crypto_sha512_final (&ctx, r);
	crypto_eddsa_reduce(r, r);

	/* First half of the signature R */
	uint8_t R[X25519_KEY_LEN];
	crypto_eddsa_scalarbase(R, r);

	/* hash(R || A || M) */
	uint8_t H[64];
	crypto_sha512_init  (&ctx);
	crypto_sha512_update(&ctx, R      , X25519_KEY_LEN);
	crypto_sha512_update(&ctx, A      , X25519_KEY_LEN);
	crypto_sha512_update(&ctx, message, message_size);
	crypto_sha512_final (&ctx, H);
	crypto_eddsa_reduce(H, H);

	/* Signature */
	memcpy(signature, R, X25519_KEY_LEN);
	crypto_eddsa_mul_add(signature + X25519_KEY_LEN, a, H, r);

	/* Wipe secrets (A, R, and H are not secret) */
	crypto_wipe(a, X25519_KEY_LEN);
	crypto_wipe(r, X25519_KEY_LEN);
}

int signature_eddsa_verification(uint8_t *signature, uint8_t *public_key, uint8_t *message, size_t message_size) {
    return (crypto_eddsa_check(signature, public_key, message, message_size));
}

int xed25519_verify(const uint8_t signature[64],
                    const uint8_t public_key[X25519_KEY_LEN],
                    const uint8_t *message, size_t message_size)
{
	/* Convert X25519 key to EdDSA */
	uint8_t A[X25519_KEY_LEN];
	crypto_x25519_to_eddsa(A, public_key);

	/* hash(R || A || M) */
	uint8_t H[64];
	crypto_sha512_ctx ctx;
	crypto_sha512_init  (&ctx);
	crypto_sha512_update(&ctx, signature, X25519_KEY_LEN);
	crypto_sha512_update(&ctx, A        , X25519_KEY_LEN);
	crypto_sha512_update(&ctx, message  , message_size);
	crypto_sha512_final (&ctx, H);
	crypto_eddsa_reduce(H, H);

	/* Check signature */
	return crypto_eddsa_check_equation(signature, A, H);
}

void test1(void) {
	uint8_t signature[64] = {0};
    uint8_t random[64];
    uint8_t secret_key[X25519_KEY_LEN];
    uint8_t public_key[X25519_KEY_LEN] = {0};
    memset(secret_key, 1, sizeof(secret_key));
    memset(random, 2, sizeof(random));
    crypto_x25519_public_key(public_key, secret_key);


    uint8_t message[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
	0x17,0xa2,0x44,0x69,0xb8,0x61,0x37,0xe8,0xc2,0x69,0xc1,0x95,0xe0,0x56,0xad,0x17,0x05,0xdb,0xd1,0xfc,0x7a,0x77,0x60,0xe9,0xfb,0xd8,0x15,0x8b,0xf2,0xc2,0x6a,0x23,
	0x87,0xf0,0x83,0x67,0xbd,0xd1,0xd4,0x93,0x12,0x80,0xc3,0x91,0x45,0x9d,0xb7,0x91,0x01,0xb6,0xdf,0xb7,0x25,0xdb,0x97,0x86,0xb9,0x10,0xf6,0xe7,0xbc,0x6f,0x4c,0x1e,
	0x65,0x14,0x49,0x54,0x65,0x14,0x57,0x64};
    xed25519_sign(signature, secret_key,random,message, sizeof(message));
    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    // printf("\nsecret_key:\n");
    // for (int i=0; i<sizeof(secret_key); i++)
        // printf("0x%.02x,",secret_key[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);

    int result = xed25519_verify(signature, public_key, message, sizeof(message));
	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);
}

void test2(void) {
	// signature from Server
	uint8_t signature[64] = {0x9b,0xce,0xae,0xcc,0x02,0x97,0x46,0xd6,0xb7,0xd0,0xeb,0xff,0xed,0xa8,0x6d,0x5c,0xe4,0x03,0x10,0x35,0x4f,0x6b,0x03,0xbc,0x78,0xcd,0x42,0xfd,0x40,0x15,0x4c,0x2d,
							 0x1f,0x6c,0x74,0xe8,0x12,0x02,0x96,0x26,0xe4,0x5a,0x75,0x01,0xb0,0x9b,0x93,0x73,0x9e,0xd4,0x60,0x74,0xf5,0x36,0x9f,0x96,0x33,0xa7,0x2b,0xb3,0x88,0x4b,0x1e,0x05};
	// uint8_t signature[64] = {0x96,0x8f,0xfd,0x3e,0x52,0x25,0xe3,0xf1,0xff,0xc3,0x84,0x08,0x87,0xaa,0x9c,0x54,0x2d,0x3c,0xc6,0x33,0xc2,0x18,0x1c,0xc9,0xc5,0xe1,0x86,0x5d,0x0c,0xe4,0x69,0x0c,
	// 						 0x2b,0x6a,0x42,0x20,0xda,0x61,0xc5,0xe5,0x0f,0x8e,0x64,0x2e,0x36,0xb3,0x80,0x06,0x28,0x0a,0x2d,0xe3,0x8f,0x1e,0xfc,0x2c,0x0c,0xa6,0x80,0xa3,0x54,0xde,0x69,0x03};
    // uint8_t random[64];
    // uint8_t secret_key[X25519_KEY_LEN];
    uint8_t public_key[X25519_KEY_LEN] = {0x27,0x92,0xc2,0x13,0xa9,0xf1,0x6d,0x08,0x0c,0x55,0xf1,0xd4,0xee,0x68,0x01,0x74,0x06,0x30,0x2a,0x6e,0xe6,0xe1,0x9e,0xae,0x01,0x2f,0xdb,0xb4,0xc4,0x7a,0x20,0x03};
    // memset(secret_key, 1, sizeof(secret_key));
    // memset(random, 2, sizeof(random));
    // crypto_x25519_public_key(public_key, secret_key);
	// message from server



    uint8_t message[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x65,0x16,0x7f,0xd5,
							0x65,0x16,0x8d,0xe5};
							// 0x65,0x14,0x49,0x54,
							// 0x65,0x14,0x57,0x64};

    // xed25519_sign(signature, secret_key,random,message, sizeof(message));
    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    // printf("\nsecret_key:\n");
    // for (int i=0; i<sizeof(secret_key); i++)
    //     printf("0x%.02x,",secret_key[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);

    int result = xed25519_verify(signature, public_key, message, sizeof(message));
	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);


	// uint8_t message1[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
	// 						0x17,0xa2,0x44,0x69,0xb8,0x61,0x37,0xe8,0xc2,0x69,0xc1,0x95,0xe0,0x56,0xad,0x17,0x05,0xdb,0xd1,0xfc,0x7a,0x77,0x60,0xe9,0xfb,0xd8,0x15,0x8b,0xf2,0xc2,0x6a,0x23,
	// 						0x87,0xf0,0x83,0x67,0xbd,0xd1,0xd4,0x93,0x12,0x80,0xc3,0x91,0x45,0x9d,0xb7,0x91,0x01,0xb6,0xdf,0xb7,0x25,0xdb,0x97,0x86,0xb9,0x10,0xf6,0xe7,0xbc,0x6f,0x4c,0x1e,
	// 						0x54,0x49,0x14,0x65,
	// 						0x64,0x57,0x14,0x65};
    // printf("\nsignature:\n");
    // for (int i=0; i<sizeof(signature); i++)
    //     printf("0x%.02x,",signature[i]);
    // printf("\nsecret_key:\n");
    // for (int i=0; i<sizeof(secret_key); i++)
    //     printf("0x%.02x,",secret_key[i]);
    // printf("\npublic_key:\n");
    // for (int i=0; i<sizeof(public_key); i++)
    //     printf("0x%.02x,",public_key[i]);

    // result = xed25519_verify(signature, public_key, message1, sizeof(message1));
	// if (result == 0)
    // 	printf("\nverify pass: %d\n",result);
	// else
	// 	printf("\nverify fail: %d\n",result);
}


void test3(void) {
	uint8_t signature[64] = {0};
    uint8_t random[64];
    uint8_t secret_key[X25519_KEY_LEN] = {0x10,0xf1,0x95,0xa5,0xde,0x4b,0x01,0xfc,0x42,0x59,0x36,0xc6,0xff,0x45,0x03,0xb1,0x07,0x55,0x1a,0x51,0x6e,0x5e,0xb9,0x63,0x24,0x8c,0x8d,0x72,0x96,0x0e,0x33,0x46};
    uint8_t public_key[X25519_KEY_LEN] = {0};
    memset(random, 1, sizeof(random));
    crypto_x25519_public_key(public_key, secret_key);

							// a4e09292b651c278b9772c569f5fa9bb13d906b46ab68c9df9dc2b4409f8a209
							// 89d9d58b2fcd62b28ddf781e635545f3772fb1370b61365b80225a2af50ddbd6
							// 89d9d58b2fcd62b28ddf781e635545f3772fb1370b61365b80225a2af50ddbd6
	uint8_t message[96] =  {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							};

    xed25519_sign(signature, secret_key,random,message, sizeof(message));
    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    printf("\nsecret_key:\n");
    for (int i=0; i<sizeof(secret_key); i++)
        printf("0x%.02x,",secret_key[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);
    printf("\nrandom:\n");
    for (int i=0; i<sizeof(random); i++)
        printf("0x%.02x,",random[i]);

    printf("\nmessage:\n");
    for (int i=0; i<sizeof(message); i++)
        printf("0x%.02x,",message[i]);

    int result = xed25519_verify(signature, public_key, message, sizeof(message));
	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);
}

void test4(void) {
    printf("generate server key\n");
    uint8_t secret_key[64] = {1};
    // generate_key(server_identity_sk, EDDSA_SK_LEN);
    uint8_t public_key[X25519_KEY_LEN];
    uint8_t seed[X25519_KEY_LEN] = {2};
	memset(seed, 2, sizeof(seed));
    printf("\nseed:\n");
    for (int i=0; i<sizeof(seed); i++)
        printf("0x%.02x,",seed[i]);
    crypto_eddsa_key_pair(secret_key, public_key, seed);
	// signature from Server
	uint8_t signature[64] =  {0};

    uint8_t message[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x65,0x1a,0x4c,0x3a,
							0x65,0x1a,0x5a,0x4a};

    crypto_eddsa_sign(signature, secret_key, message, sizeof(message));


    printf("\nsecret_key:\n");
    for (int i=0; i<sizeof(secret_key); i++)
        printf("0x%.02x,",secret_key[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);
    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    printf("\nmessage:\n");
    for (int i=0; i<sizeof(message); i++)
        printf("0x%.02x,",message[i]);
    int result = signature_eddsa_verification(signature, public_key, message, sizeof(message));
	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);

}


void test5(void) {

	FILE* fptr_id;
	fptr_id = fopen("server.bin", "wb");

	uint8_t signature[64] =  {0x80,0xc9,0x01,0x38,0x4a,0x9f,0x4d,0x7f,0xd8,0x76,0x08,0x35,0x0f,0xea,0x89,0x1e,0x2d,0x41,0xb8,0x34,0x43,0x18,0x71,0xf9,0x59,0x78,0xaf,0xfd,0x1f,0xef,0x5c,0x0b,
							  0xef,0x55,0xa3,0x0f,0x01,0x94,0xcf,0xb6,0x6b,0x33,0x30,0xfb,0x40,0xb6,0xd5,0xe0,0x1a,0xad,0x11,0x8c,0x8c,0x37,0xf1,0x56,0x5d,0x2f,0xa9,0xb5,0x71,0x82,0xc3,0x04};
	uint8_t public_key[X25519_KEY_LEN] = {0x4f,0x63,0x2d,0x21,0xc7,0xce,0x86,0x7f,0x03,0x1b,0x28,0xbc,0x96,0x30,0x90,0x74,0xe4,0x1c,0x26,0xb1,0x0d,0x59,0x08,0xf6,0xa4,0x1b,0x10,0x15,0x03,0x3c,0xe5,0x1e};

    uint8_t message[104] = {0xa4,0xe0,0x92,0x92,0xb6,0x51,0xc2,0x78,0xb9,0x77,0x2c,0x56,0x9f,0x5f,0xa9,0xbb,0x13,0xd9,0x06,0xb4,0x6a,0xb6,0x8c,0x9d,0xf9,0xdc,0x2b,0x44,0x09,0xf8,0xa2,0x09,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x89,0xd9,0xd5,0x8b,0x2f,0xcd,0x62,0xb2,0x8d,0xdf,0x78,0x1e,0x63,0x55,0x45,0xf3,0x77,0x2f,0xb1,0x37,0x0b,0x61,0x36,0x5b,0x80,0x22,0x5a,0x2a,0xf5,0x0d,0xdb,0xd6,
							0x65,0x1a,0x4c,0x3a,
							0x65,0x1a,0x5a,0x4a};

	fwrite(public_key,X25519_KEY_LEN,1,fptr_id);
	fclose(fptr_id);


    printf("\nsignature:\n");
    for (int i=0; i<sizeof(signature); i++)
        printf("0x%.02x,",signature[i]);
    printf("\npublic_key:\n");
    for (int i=0; i<sizeof(public_key); i++)
        printf("0x%.02x,",public_key[i]);
    printf("\nmessage:\n");
    for (int i=0; i<sizeof(message); i++)
        printf("0x%.02x,",message[i]);
    // int result = signature_eddsa_verification(signature, public_key, message, sizeof(message));
	int result =  crypto_ed25519_check(signature, public_key, message, sizeof(message));

	if (result == 0)
    	printf("\nverify pass: %d\n",result);
	else
		printf("\nverify fail: %d\n",result);

	fptr_id = fopen("server.bin", "rb");
    fseek(fptr_id, 0, SEEK_END);          
    int filelen = ftell(fptr_id);
	rewind(fptr_id);
	uint8_t check_server_key[64] = {0};
    for(int i = 0; i < filelen; i++) {
       fread(&check_server_key[i], 1, 1, fptr_id); 
    }

    printf("\nFile len: %d\n", filelen);
    printf("\ncheck_server_key:\n");
    for (int i=0; i<sizeof(check_server_key); i++)
        printf("0x%.02x,",check_server_key[i]);

    fclose(fptr_id); // Close the file

}


void random_keys(uint8_t* array, int len) {
	for (int i=0; i<len; i++)
		array[i] = rand();
}
void generate_bike_keys(void) {

#define BIKE_NUM 10

	FILE* fptr_id[BIKE_NUM];
	FILE* fptr_pair[BIKE_NUM];
	FILE* fptr_server;

	char* bike_id[BIKE_NUM] = {		"bike01.bin",
									"bike02.bin",
					 				"bike03.bin",
									"bike04.bin",
					 				"bike05.bin",
									"bike06.bin",
									"bike07.bin",
					 				"bike08.bin",
									"bike09.bin",
					 				"bike10.bin"};
	char* bike_pair[BIKE_NUM] = {	"pair01.bin",
									"pair02.bin",
					 				"pair03.bin",
									"pair04.bin",
					 				"pair05.bin",
									"pair06.bin",
									"pair07.bin",
					 				"pair08.bin",
									"pair09.bin",
					 				"pair10.bin"};

	uint8_t id_pk[X25519_KEY_LEN] = {0};
	uint8_t id_sk[X25519_KEY_LEN] = {0};
	uint8_t pair_pk[X25519_KEY_LEN] = {0};
	uint8_t pair_sk[X25519_KEY_LEN] = {0};
	uint8_t server_pk[X25519_KEY_LEN] = {0x4f,0x63,0x2d,0x21,0xc7,0xce,0x86,0x7f,0x03,0x1b,0x28,0xbc,0x96,0x32,0x90,0x74,0xe4,0x1c,0x26,0xb1,0x0d,0x59,0x08,0xf6,0xa4,0x1b,0x10,0x15,0x03,0x3c,0xe5,0x1e};

	printf("create server.bin file\n");
	fptr_server = fopen("server.bin", "wb");
	fwrite(server_pk,X25519_KEY_LEN,1,fptr_server);
	fclose(fptr_server);


	printf("create bike.bin file\n");
	for (int i=0; i<BIKE_NUM; i++) {
		remove(bike_id[i]);
		remove(bike_pair[i]);
		fptr_id[i] = fopen(bike_id[i], "wb");
		fptr_pair[i] = fopen(bike_pair[i], "wb");

		random_keys(id_sk, sizeof(id_sk));
		random_keys(pair_sk, sizeof(pair_sk));

    	crypto_x25519_public_key(id_pk, id_sk);
    	crypto_x25519_public_key(pair_pk, pair_sk);

		fwrite(id_sk,X25519_KEY_LEN,1,fptr_id[i]);
		fwrite(id_pk,X25519_KEY_LEN,1,fptr_id[i]);

		fwrite(pair_sk,X25519_KEY_LEN,1,fptr_pair[i]);
		fwrite(pair_pk,X25519_KEY_LEN,1,fptr_pair[i]);

		fclose(fptr_id[i]);
		fclose(fptr_pair[i]);
	}

	printf("check server.bin file\n");
	uint8_t check_key[X25519_KEY_LEN + X25519_KEY_LEN] = {0};
	for (int i=0; i<BIKE_NUM; i++) {
		fptr_id[i] = fopen(bike_id[i], "rb");
		fptr_pair[i] = fopen(bike_pair[i], "rb");

		fseek(fptr_id[i], 0, SEEK_END);          
		int filelen = ftell(fptr_id[i]);
		// printf("filelen: %d\n",filelen);
		rewind(fptr_id[i]);
		memset(check_key, 0, sizeof(check_key));
		for(int j = 0; j < filelen; j++) {
			fread(&check_key[j], 1, 1, fptr_id[i]); 
		}

		printf("\nsk:\n");
		for (int j=0; j<X25519_KEY_LEN; j++) {
			printf("%.02x",check_key[j]);
		}

		printf("\npk:\n");
		for (int j=0; j<X25519_KEY_LEN; j++) {
			printf("%.02x",check_key[X25519_KEY_LEN + j]);
		}

		fseek(fptr_pair[i], 0, SEEK_END);          
		filelen = ftell(fptr_pair[i]);
		// printf("filelen: %d\n",filelen);
		rewind(fptr_pair[i]);
		memset(check_key, 0, sizeof(check_key));
		for(int j = 0; j < filelen; j++) {
			fread(&check_key[j], 1, 1, fptr_pair[i]); 
		}

		printf("\npair_sk:\n");
		for (int j=0; j<X25519_KEY_LEN; j++) {
			printf("%.02x",check_key[j]);
		}
		printf("\npair_pk:\n");
		for (int j=0; j<X25519_KEY_LEN; j++) {
			printf("%.02x",check_key[X25519_KEY_LEN + j]);
		}

		fclose(fptr_id[i]);
		fclose(fptr_pair[i]);
	}

	fptr_server = fopen("server.bin", "rb");
	fseek(fptr_server, 0, SEEK_END);          
	int filelen = ftell(fptr_server);
	rewind(fptr_server);
	memset(check_key, 0, sizeof(check_key));
	for(int i = 0; i < filelen; i++) {
		fread(&check_key[i], 1, 1, fptr_server); 
	}
	printf("\nserver:\n");
	for (int i=0; i<sizeof(check_key); i++) {
		printf("%.02x",check_key[i]);
	}
	fclose(fptr_server);
	printf("\n");
}


void generate_server_key(void) {

	FILE* fptr_id;
	fptr_id = fopen("server.bin", "wb");

	uint8_t public_key[X25519_KEY_LEN] = {0x4f,0x63,0x2d,0x21,0xc7,0xce,0x86,0x7f,0x03,0x1b,0x28,0xbc,0x96,0x32,0x90,0x74,0xe4,0x1c,0x26,0xb1,0x0d,0x59,0x08,0xf6,0xa4,0x1b,0x10,0x15,0x03,0x3c,0xe5,0x1e};
	fwrite(public_key,X25519_KEY_LEN,1,fptr_id);
	fclose(fptr_id);
}

// 10f195a5de4b01fc425936c6ff4503b107551a516e5eb96X25519_KEY_LEN48c8d72960e3346
int main(void) {
	srand(time(NULL));   // Initialization, should only be called once.
	// printf("test 1\n");
    // test1();
	// printf("test 2\n");
	// test2();
	// printf("test 3\n");
	// test3();
	// printf("test 4\n");
	// test4();
	// printf("test 5\n");
	// test5();
	printf("generate keys\n");
	// generate_bike_keys();
	generate_server_key();
    return 0;
}

